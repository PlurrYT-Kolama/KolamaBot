"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseManager = void 0;
const events_1 = require("events");
const fs_1 = require("fs");
const util_1 = require("util");
const writeFileAsync = (0, util_1.promisify)(fs_1.writeFile);
const existsAsync = (0, util_1.promisify)(fs_1.exists);
const readFileAsync = (0, util_1.promisify)(fs_1.readFile);
/**
 * Ticket Manager
 * @extends {EventEmitter}
 */
class BaseManager extends events_1.EventEmitter {
    /**
     * @param {Client} client Discord Client
     * @param {TicketManagerOptions} [options] TicketManager options
     */
    constructor(client, options) {
        super();
        /**
         * The Discord Client
         * @readonly
         * @type {Client}
         */
        if (!client)
            throw new Error('Client is a required option.');
        this.client = client;
        /**
         * The manager options
         * @type {TicketManagerOptions}
         */
        this.options = options;
        /**
         * Array with all tickets
         * @type {Array<TicketData>}
         */
        this.ticketRaws = [];
    }
    /**
     * Get All ticket raw from Database/JSON storage
     * @return {Promise<Array<TicketData>>}
     */
    getAllTickets() {
        return __awaiter(this, void 0, void 0, function* () {
            // Whether the storage file exists, or not
            const storageExists = yield existsAsync(this.options.storage);
            // If it doesn't exists
            if (!storageExists) {
                // Create the file with an empty array
                yield writeFileAsync(this.options.storage, '[]', 'utf-8');
                return [];
            }
            else {
                // If the file exists, read it
                const storageContent = yield readFileAsync(this.options.storage);
                try {
                    const tickets = yield JSON.parse(storageContent.toString());
                    if (Array.isArray(tickets)) {
                        return tickets;
                    }
                    else {
                        console.log(storageContent, tickets);
                        throw new SyntaxError('The storage file is not properly formatted (tickets is not an array).');
                    }
                }
                catch (e) {
                    // @ts-ignore
                    if (e.message === 'Unexpected end of JSON input') {
                        throw new SyntaxError('The storage file is not properly formatted (Unexpected end of JSON input).');
                    }
                    else {
                        throw e;
                    }
                }
            }
        });
    }
    /**
     * Save all tickets on Database/JSON storage
     * @return {Promise<boolean>}
     */
    saveTicketRaws() {
        return __awaiter(this, void 0, void 0, function* () {
            yield writeFileAsync(this.options.storage, JSON.stringify(this.ticketRaws), 'utf-8');
            return true;
        });
    }
    /**
     * Check if member already has ticket
     * @param {string} guildID Discord Guild Id
     * @param {string} memberID Discord Guild Member Id
     * @return {boolean}
     */
    checkDoubleTickets(guildID, memberID) {
        if (this.ticketRaws.find(x => x.guild === guildID && x.member === memberID)) {
            return true
        } else {
            return false
        }
        //return !!this.ticketRaws.find(x => x.guild === guildID && x.member === memberID);
    }
    /**
     * Get Guild Class from client cache (is you're using shards)
     * @param {string} id Discord Guild Id
     * @return {Promise<Guild>}
     */
    getGuild(id) {
        return this.client.guilds.cache.get(id);
    }
}
exports.BaseManager = BaseManager;
/**
 * Storage File path:
 * * "Json file path"
 * * "custom"
 * @typedef {string} StorageType
 */
/**
 * Base Manager Config Types
 * @typedef {object} BaseManagerOptions
 * @property {boolean} enabled Manager status
 * @property {string} staffRole Discord Role id who can access to tickets
 * @property {boolean} ticketCache Storing tickets in the cache
 * @property {StorageType} storage Storage File path
 */ 
